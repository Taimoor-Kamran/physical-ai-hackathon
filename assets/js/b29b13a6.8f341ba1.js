"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[1971],{6800:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"localization-mapping","title":"Localization & Mapping","description":"Theory","source":"@site/docs/localization-mapping.mdx","sourceDirName":".","slug":"/localization-mapping","permalink":"/physical-ai-hackathon/docs/localization-mapping","draft":false,"unlisted":false,"editUrl":"https://github.com/Taimoor-Kamran/physical-ai-hackathon/edit/main/frontend/docs/localization-mapping.mdx","tags":[],"version":"current","frontMatter":{"title":"Localization & Mapping","sidebar_label":"Localization & Mapping"},"sidebar":"docs","previous":{"title":"Perception","permalink":"/physical-ai-hackathon/docs/perception"},"next":{"title":"Path Planning","permalink":"/physical-ai-hackathon/docs/path-planning"}}');var o=i(4848),a=i(8453);const r={title:"Localization & Mapping",sidebar_label:"Localization & Mapping"},s="Localization & Mapping",l={},c=[{value:"Theory",id:"theory",level:2},{value:"Localization",id:"localization",level:3},{value:"Mapping",id:"mapping",level:3},{value:"Simultaneous Localization and Mapping (SLAM)",id:"simultaneous-localization-and-mapping-slam",level:3},{value:"Code",id:"code",level:2},{value:"Gazebo Simulation",id:"gazebo-simulation",level:2},{value:"Real Robot Mapping",id:"real-robot-mapping",level:2},{value:"Hardware Requirements:",id:"hardware-requirements",level:3},{value:"Lab Exercise",id:"lab-exercise",level:2},{value:"Objective:",id:"objective",level:4},{value:"Instructions:",id:"instructions",level:4}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"localization--mapping",children:"Localization & Mapping"})}),"\n",(0,o.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,o.jsx)(n.p,{children:"Localization and mapping are two of the most fundamental problems in robotics, especially for autonomous mobile robots. A robot needs to know where it is (localization) and what its environment looks like (mapping) to navigate effectively. These two problems are often intertwined, leading to the concept of Simultaneous Localization and Mapping (SLAM)."}),"\n",(0,o.jsx)(n.h3,{id:"localization",children:"Localization"}),"\n",(0,o.jsx)(n.p,{children:"Localization is the process of determining a robot's position and orientation within a given map. This is crucial for path planning and executing tasks accurately. Robots use various sensors and algorithms for localization:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Odometry:"})," Using wheel encoders or IMUs (Inertial Measurement Units) to estimate movement relative to a starting point. It's prone to drift over time due to accumulating errors."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Global Localization:"})," Determining the robot's position from scratch in a known map, even if it has no prior pose information."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kidnapped Robot Problem:"})," A specific localization challenge where a robot, assuming it knows its location, is suddenly moved to an unknown position in a known map. The robot must re-localize itself."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Common localization algorithms:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kalman Filters (KF/EKF/UKF):"})," State estimation algorithms that fuse sensor data over time to predict and update the robot's pose, accounting for noise and uncertainty."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Particle Filters (Monte Carlo Localization - MCL):"})," A set of weighted samples (particles) represent the robot's belief about its position. Particles are propagated based on motion and re-weighted based on sensor observations."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"mapping",children:"Mapping"}),"\n",(0,o.jsx)(n.p,{children:"Mapping is the process of building a representation of the environment. This map can be used for navigation, obstacle avoidance, and task execution."}),"\n",(0,o.jsx)(n.p,{children:"Types of maps:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Occupancy Grid Maps:"})," Represent the environment as a grid where each cell stores the probability of being occupied by an obstacle."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Feature-based Maps:"})," Store distinct features (e.g., landmarks, corners) and their locations."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Topological Maps:"})," Represent the environment as a graph of locations and the connections between them, abstracting away geometric details."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"simultaneous-localization-and-mapping-slam",children:"Simultaneous Localization and Mapping (SLAM)"}),"\n",(0,o.jsx)(n.p,{children:"SLAM is the problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent's location within it. It's a chicken-and-egg problem: a good map is needed for accurate localization, and accurate localization is needed to build a good map. Modern SLAM systems typically use iterative approaches to refine both the map and the robot's pose simultaneously."}),"\n",(0,o.jsx)(n.h2,{id:"code",children:"Code"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Example: Simple 2D Odometry for a Differential Drive Robot\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nclass DifferentialDriveRobot:\n    def __init__(self, wheel_radius=0.05, wheel_base=0.2, dt=0.1):\n        self.r = wheel_radius  # Wheel radius (m)\n        self.L = wheel_base    # Distance between wheels (m)\n        self.dt = dt           # Time step (s)\n\n        # Robot state (x, y, theta)\n        self.x = 0.0\n        self.y = 0.0\n        self.theta = 0.0 # radians\n\n    def update_odometry(self, left_wheel_velocity, right_wheel_velocity):\n        # Calculate linear and angular velocity of the robot\n        v_linear = self.r * (right_wheel_velocity + left_wheel_velocity) / 2.0\n        v_angular = self.r * (right_wheel_velocity - left_wheel_velocity) / self.L\n\n        # Update robot pose using differential drive kinematics\n        if abs(v_angular) > 1e-6: # Avoid division by zero for straight motion\n            # Arc motion\n            R = v_linear / v_angular # Radius of curvature\n            icc_x = self.x - R * np.sin(self.theta)\n            icc_y = self.y + R * np.cos(self.theta)\n\n            self.x = icc_x + R * np.sin(self.theta + v_angular * self.dt)\n            self.y = icc_y - R * np.cos(self.theta + v_angular * self.dt)\n            self.theta += v_angular * self.dt\n        else:\n            # Straight motion\n            self.x += v_linear * np.cos(self.theta) * self.dt\n            self.y += v_linear * np.sin(self.theta) * self.dt\n\n        # Normalize theta to be between -pi and pi\n        self.theta = np.arctan2(np.sin(self.theta), np.cos(self.theta))\n\n    def get_pose(self):\n        return self.x, self.y, self.theta\n\n# Example Usage:\nrobot = DifferentialDriveRobot()\n\n# Store trajectory for plotting\ntrajectory_x = [robot.x]\ntrajectory_y = [robot.y]\n\n# Simulate movement\nfor i in range(100):\n    # Move straight for a while\n    if i < 50:\n        left_vel = 1.0 # rad/s\n        right_vel = 1.0 # rad/s\n    else:\n        # Turn left\n        left_vel = 0.5\n        right_vel = 1.5\n\n    robot.update_odometry(left_vel, right_vel)\n    x, y, theta = robot.get_pose()\n    trajectory_x.append(x)\n    trajectory_y.append(y)\n\n    # print(f\"Step {i}: x={x:.2f}, y={y:.2f}, theta={np.rad2deg(theta):.2f}\")\n\nplt.figure(figsize=(8, 8))\nplt.plot(trajectory_x, trajectory_y, marker='o', markersize=2, label='Robot Trajectory')\nplt.xlabel('X Position (m)')\nplt.ylabel('Y Position (m)')\nplt.title('Simulated 2D Differential Drive Robot Odometry')\nplt.grid(True)\nplt.axis('equal')\nplt.legend()\nplt.show()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"gazebo-simulation",children:"Gazebo Simulation"}),"\n",(0,o.jsxs)(n.p,{children:["Gazebo provides extensive capabilities for simulating localization and mapping. Robots equipped with simulated sensors (e.g., LiDAR, cameras, IMUs) can generate realistic data streams. These data streams can then be fed into ROS packages for SLAM (e.g., ",(0,o.jsx)(n.code,{children:"gmapping"}),", ",(0,o.jsx)(n.code,{children:"Cartographer"}),", ",(0,o.jsx)(n.code,{children:"Hector SLAM"}),") or odometry estimation (e.g., ",(0,o.jsx)(n.code,{children:"robot_localization"})," using EKFs/UKFs). Developers can test different SLAM configurations, sensor placements, and algorithm parameters in a reproducible virtual environment."]}),"\n",(0,o.jsx)(n.h2,{id:"real-robot-mapping",children:"Real Robot Mapping"}),"\n",(0,o.jsx)(n.p,{children:"On real robots, achieving accurate and robust localization and mapping is challenging due to sensor noise, dynamic environments, computational constraints, and the need for real-time performance. Effective SLAM systems often fuse data from multiple sensors (e.g., LiDAR, cameras, IMU, GPS). Post-processing techniques like loop closure detection (recognizing previously visited locations) are crucial for correcting drift and building globally consistent maps. The choice of SLAM algorithm depends on the robot's capabilities, sensor suite, and the characteristics of the operating environment."}),"\n",(0,o.jsx)(n.h3,{id:"hardware-requirements",children:"Hardware Requirements:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mobile Robot Platform:"})," With differential drive or omnidirectional capabilities."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"LiDAR Sensor:"})," For creating 2D or 3D occupancy maps and robust localization."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"IMU (Inertial Measurement Unit):"})," For odometry, attitude estimation, and motion tracking."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Wheel Encoders:"})," For basic odometry measurement."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Powerful Onboard Computer:"})," To run SLAM algorithms and process sensor data in real-time."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Optional:"})," Depth Camera (e.g., Intel RealSense) for visual SLAM or dense mapping."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Optional:"})," GPS (for outdoor environments) for global position estimates."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"lab-exercise",children:"Lab Exercise"}),"\n",(0,o.jsx)(n.h4,{id:"objective",children:"Objective:"}),"\n",(0,o.jsx)(n.p,{children:"Simulate a differential drive robot and visualize its odometry-based trajectory."}),"\n",(0,o.jsx)(n.h4,{id:"instructions",children:"Instructions:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Run the Odometry Simulation:"})," Execute the provided Python code for the ",(0,o.jsx)(n.code,{children:"DifferentialDriveRobot"}),". Observe the plotted trajectory of the robot."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Experiment with Motion:"})," Modify the ",(0,o.jsx)(n.code,{children:"left_vel"})," and ",(0,o.jsx)(n.code,{children:"right_vel"})," values in the simulation loop. Make the robot move in a circle, a figure-eight, or a zigzag pattern. How do changes in wheel velocities affect the robot's path and orientation?"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Introduce Noise/Error (Challenge):"})," Simulate odometry drift by adding a small, cumulative error to the ",(0,o.jsx)(n.code,{children:"left_wheel_velocity"})," or ",(0,o.jsx)(n.code,{children:"right_wheel_velocity"})," at each time step. Observe how this error accumulates and affects the accuracy of the robot's estimated pose over a long trajectory."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visualize Pose:"})," In addition to the trajectory, try to plot small arrows or markers on the robot's path to indicate its orientation (",(0,o.jsx)(n.code,{children:"theta"}),") at different points in time. This will help visualize the full pose."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Research SLAM Concepts:"})," Briefly research how a Kalman Filter or Particle Filter could be used to improve the localization accuracy of this robot by incorporating external sensor data (e.g., simulated landmark observations or GPS)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);