"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[7554],{8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const r={},o=s.createContext(r);function t(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(o.Provider,{value:n},e.children)}},9609:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ros2-gazebo","title":"ROS 2 & Gazebo","description":"Theory","source":"@site/docs/ros2-gazebo.mdx","sourceDirName":".","slug":"/ros2-gazebo","permalink":"/physical-ai-hackathon/docs/ros2-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/Taimoor-Kamran/physical-ai-hackathon/edit/main/frontend/docs/ros2-gazebo.mdx","tags":[],"version":"current","frontMatter":{"title":"ROS 2 & Gazebo","sidebar_label":"ROS 2 & Gazebo"},"sidebar":"docs","previous":{"title":"Human-Robot Interaction","permalink":"/physical-ai-hackathon/docs/human-robot-interaction"},"next":{"title":"NVIDIA Isaac Sim","permalink":"/physical-ai-hackathon/docs/nvidia-isaac"}}');var r=i(4848),o=i(8453);const t={title:"ROS 2 & Gazebo",sidebar_label:"ROS 2 & Gazebo"},a="ROS 2 & Gazebo",l={},c=[{value:"Theory",id:"theory",level:2},{value:"Code",id:"code",level:2},{value:"Gazebo Simulation",id:"gazebo-simulation",level:2},{value:"Real Robot Mapping",id:"real-robot-mapping",level:2},{value:"Hardware Requirements:",id:"hardware-requirements",level:3},{value:"Lab Exercise",id:"lab-exercise",level:2},{value:"Objective:",id:"objective",level:4},{value:"Instructions:",id:"instructions",level:4}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ros-2--gazebo",children:"ROS 2 & Gazebo"})}),"\n",(0,r.jsx)(n.h2,{id:"theory",children:"Theory"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 (Robot Operating System 2) and Gazebo are foundational tools for modern robotics development. ROS 2 provides a flexible framework for writing robot software, offering libraries, tools, and conventions that simplify the creation of complex robot applications. Gazebo is a powerful 3D simulator that accurately simulates robot dynamics, sensors, and environments, allowing developers to test algorithms and robot designs in a safe, repeatable, and cost-effective virtual setting before deploying to real hardware."}),"\n",(0,r.jsx)(n.p,{children:"Key concepts in ROS 2:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes:"})," Executable processes that perform computation (e.g., a sensor driver node, a path planning node)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Topics:"})," Named buses over which nodes exchange messages (e.g., ",(0,r.jsx)(n.code,{children:"/cmd_vel"})," for velocity commands, ",(0,r.jsx)(n.code,{children:"/odom"})," for odometry data)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Services:"})," Request/reply communication for tasks that require a response (e.g., ",(0,r.jsx)(n.code,{children:"set_gripper_state"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actions:"})," Long-running tasks with feedback and preemption capabilities (e.g., ",(0,r.jsx)(n.code,{children:"navigate_to_pose"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters:"})," Configuration values that can be set and retrieved by nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Packages:"})," The fundamental unit of ROS 2 software organization, containing nodes, libraries, configuration files, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Launch Files:"})," XML or Python files used to start multiple ROS 2 nodes and configure their parameters."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Key aspects of Gazebo:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics Engine:"})," Simulates rigid body dynamics, contact, and friction."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensors:"})," Realistic simulation of cameras, LiDAR, IMUs, force sensors, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Worlds:"})," XML files defining the environment, including models, lighting, and physics properties."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Models:"})," URDF (Unified Robot Description Format) or SDF (Simulation Description Format) files defining robot kinematics, dynamics, and visual appearance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Plugins:"})," Extend Gazebo's functionality, often used to bridge ROS 2 with Gazebo for robot control and sensor data publication."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"code",children:"Code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Example: Simple ROS 2 Publisher and Subscriber (simulated)\n# This code block is conceptual and demonstrates the ROS 2 API.\n# To run actual ROS 2 code, you would need a ROS 2 environment set up.\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nimport time\n\nclass SimplePublisher(Node):\n    def __init__(self):\n        super().__init__('simple_publisher')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello ROS 2! Count: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\nclass SimpleSubscriber(Node):\n    def __init__(self):\n        super().__init__('simple_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    # This is a conceptual representation.\n    # In a real ROS 2 setup, you would typically run publisher and subscriber\n    # nodes in separate processes.\n    print(\"Simulating ROS 2 nodes. In a real scenario, run with `ros2 run`.\")\n\n    # Simulate running nodes\n    publisher_node = SimplePublisher()\n    subscriber_node = SimpleSubscriber()\n\n    # Simple loop to simulate ROS 2 spin for a short duration\n    for _ in range(5):\n        rclpy.spin_once(publisher_node, timeout_sec=0.1)\n        rclpy.spin_once(subscriber_node, timeout_sec=0.1)\n        time.sleep(0.5)\n\n    print(\"\\nSimulation finished.\")\n\n    # These lines would be part of a real ROS 2 main function\n    # rclpy.init(args=args)\n    #\n    # publisher_node = SimplePublisher()\n    # subscriber_node = SimpleSubscriber()\n    #\n    # executor = rclpy.executors.MultiThreadedExecutor()\n    # executor.add_node(publisher_node)\n    # executor.add_node(subscriber_node)\n    #\n    # try:\n    #     executor.spin()\n    # except KeyboardInterrupt:\n    #     pass\n    #\n    # publisher_node.destroy_node()\n    # subscriber_node.destroy_node()\n    # rclpy.shutdown()\n\nif __name__ == '__main__':\n    # This will only run the conceptual simulation.\n    # For actual ROS 2, `rclpy.init()` would be needed.\n    # As rclpy is not available in this environment, this is a placeholder.\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"gazebo-simulation",children:"Gazebo Simulation"}),"\n",(0,r.jsxs)(n.p,{children:["Gazebo is tightly integrated with ROS 2 through various bridge packages (e.g., ",(0,r.jsx)(n.code,{children:"ros_gz_sim"}),"). This integration allows Gazebo to publish sensor data to ROS 2 topics and subscribe to ROS 2 topics for robot control commands."]}),"\n",(0,r.jsx)(n.p,{children:"A typical workflow involves:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Defining the Robot:"})," Creating a URDF or SDF file for the robot, including its links, joints, sensors, and actuators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Creating a Gazebo World:"})," Defining the simulation environment (e.g., a factory floor, an outdoor scene) using an SDF world file."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integrating ROS 2:"})," Using Gazebo plugins (like ",(0,r.jsx)(n.code,{children:"libgazebo_ros_diff_drive"})," for mobile robots or ",(0,r.jsx)(n.code,{children:"libgazebo_ros_joint_state_publisher"})," for joint states) to enable communication between Gazebo's physics engine and ROS 2 topics."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Launching the Simulation:"})," Using ROS 2 launch files to start Gazebo with the specified robot and world, along with any necessary ROS 2 nodes for control, navigation, or perception."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Gazebo provides realistic physics (gravity, friction, collisions) and high-fidelity sensor models (cameras, LiDAR, IMUs), making it an invaluable tool for developing and testing complex robotic systems in a safe and reproducible virtual environment."}),"\n",(0,r.jsx)(n.h2,{id:"real-robot-mapping",children:"Real Robot Mapping"}),"\n",(0,r.jsx)(n.p,{children:"Deploying ROS 2 applications from simulation to a real robot involves addressing several key challenges:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Abstraction Layer:"})," ROS 2 drivers are needed for real sensors and actuators to match the interfaces provided by Gazebo's simulated sensors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Noise and Latency:"})," Real-world sensor data is inherently noisy and subject to latency, which algorithms developed in perfect simulation must be robust against."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actuator Limitations:"})," Real motors have limitations in torque, speed, and precision that need to be accounted for in control algorithms."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Calibration:"})," Accurate calibration of sensors, robot kinematics, and environment models is critical for real-world performance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety:"})," Implementing robust safety protocols, including emergency stops and collision avoidance, is paramount for real robots operating in physical environments."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Despite these challenges, ROS 2's modular architecture and strong community support provide a pathway to bridge the gap between simulation and real-world deployment."}),"\n",(0,r.jsx)(n.h3,{id:"hardware-requirements",children:"Hardware Requirements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Robot Controller:"})," A robust embedded computer (e.g., NVIDIA Jetson, Raspberry Pi 4, industrial PC) capable of running ROS 2."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 Compatible Sensors:"})," LiDAR, cameras (RGB, depth), IMUs, force/torque sensors with available ROS 2 drivers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 Compatible Actuators:"})," Motors, servos, grippers with control interfaces that can be driven by ROS 2 control nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Networking:"})," Reliable Ethernet or Wi-Fi connectivity for inter-robot communication and remote monitoring."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Power Management:"})," Sufficient power supply for all robot components."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"lab-exercise",children:"Lab Exercise"}),"\n",(0,r.jsx)(n.h4,{id:"objective",children:"Objective:"}),"\n",(0,r.jsx)(n.p,{children:"Understand the fundamental concepts of ROS 2 nodes, topics, and message passing."}),"\n",(0,r.jsx)(n.h4,{id:"instructions",children:"Instructions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conceptual Code Review:"})," Carefully review the provided Python code for ",(0,r.jsx)(n.code,{children:"SimplePublisher"})," and ",(0,r.jsx)(n.code,{children:"SimpleSubscriber"}),". Identify where messages are created, published, and received."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 Environment Setup (External):"})," If you have access to a machine with ROS 2 (e.g., ROS 2 Humble on Ubuntu), try to run the conceptual publisher and subscriber in a real ROS 2 environment. You would typically save these as ",(0,r.jsx)(n.code,{children:"publisher_node.py"})," and ",(0,r.jsx)(n.code,{children:"subscriber_node.py"})," in a ROS 2 package, make them executable, and then run them with ",(0,r.jsx)(n.code,{children:"ros2 run <package_name> publisher_node"})," and ",(0,r.jsx)(n.code,{children:"ros2 run <package_name> subscriber_node"})," in separate terminals."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modify Message Content:"})," In the ",(0,r.jsx)(n.code,{children:"SimplePublisher"})," class, change the content of the ",(0,r.jsx)(n.code,{children:"msg.data"})," (e.g., ",(0,r.jsx)(n.code,{children:"msg.data = f'Greetings from my robot! Iteration: {self.i}'"}),"). Observe how the subscriber node's output changes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Change Topic Name (Challenge):"})," Modify both the ",(0,r.jsx)(n.code,{children:"SimplePublisher"})," and ",(0,r.jsx)(n.code,{children:"SimpleSubscriber"})," to use a different topic name (e.g., ",(0,r.jsx)(n.code,{children:"'robot_talk'"}),"). What happens if they are not using the same topic name?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Introduce a Custom Message Type (Challenge):"})," Research how to define a custom ROS 2 message (e.g., a message containing a robot's ",(0,r.jsx)(n.code,{children:"x, y, z"})," position). Modify the publisher to send this custom message and the subscriber to receive and process it. This will involve creating a ",(0,r.jsx)(n.code,{children:".msg"})," file and updating your ",(0,r.jsx)(n.code,{children:"package.xml"})," and ",(0,r.jsx)(n.code,{children:"CMakeLists.txt"})," (in a real ROS 2 package)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);