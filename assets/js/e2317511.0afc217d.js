"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[84],{3655:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"control-systems","title":"Control Systems","description":"Theory","source":"@site/docs/control-systems.mdx","sourceDirName":".","slug":"/control-systems","permalink":"/physical-ai-hackathon/docs/control-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/Taimoor-Kamran/physical-ai-hackathon/edit/main/frontend/docs/control-systems.mdx","tags":[],"version":"current","frontMatter":{"title":"Control Systems","sidebar_label":"Control Systems"},"sidebar":"docs","previous":{"title":"Dynamics","permalink":"/physical-ai-hackathon/docs/dynamics"},"next":{"title":"Sensors & Actuators","permalink":"/physical-ai-hackathon/docs/sensors-actuators"}}');var r=n(4848),i=n(8453);const s={title:"Control Systems",sidebar_label:"Control Systems"},l="Control Systems",a={},c=[{value:"Theory",id:"theory",level:2},{value:"Code",id:"code",level:2},{value:"Gazebo Simulation",id:"gazebo-simulation",level:2},{value:"Real Robot Mapping",id:"real-robot-mapping",level:2},{value:"Hardware Requirements:",id:"hardware-requirements",level:3},{value:"Lab Exercise",id:"lab-exercise",level:2},{value:"Objective:",id:"objective",level:4},{value:"Instructions:",id:"instructions",level:4}];function d(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.header,{children:(0,r.jsx)(o.h1,{id:"control-systems",children:"Control Systems"})}),"\n",(0,r.jsx)(o.h2,{id:"theory",children:"Theory"}),"\n",(0,r.jsx)(o.p,{children:'Control systems are fundamental to robotics, enabling robots to perform tasks autonomously, precisely, and safely. A control system is a device or set of devices that manages, commands, directs, or regulates the behavior of other devices or systems. In robotics, control systems are responsible for taking high-level commands (e.g., "move to x, y, z") and translating them into low-level actions (e.g., joint torques or velocities) to achieve the desired motion while accounting for disturbances and uncertainties.'}),"\n",(0,r.jsx)(o.p,{children:"Key components of a robot control system include:"}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Sensors:"})," To measure the robot's current state (e.g., joint positions, velocities, forces, external environment)."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Controller:"}),' The "brain" that processes sensor feedback, compares it to desired states (setpoints), and generates control signals.']}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Actuators:"})," Devices that convert control signals into physical motion (e.g., motors, hydraulics)."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Feedback Loop:"})," The continuous process of measuring, comparing, and actuating to correct errors."]}),"\n"]}),"\n",(0,r.jsx)(o.p,{children:"Common types of control strategies in robotics include:"}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Open-Loop Control:"})," Control action is independent of the output. Simple but highly sensitive to disturbances and model inaccuracies."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Closed-Loop (Feedback) Control:"})," Control action depends on the output. More robust and accurate, as it actively corrects errors. PID (Proportional-Integral-Derivative) controllers are a classic example."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Advanced Control:"})," Includes adaptive control, robust control, optimal control, and learning-based control, which are designed to handle complex dynamics, uncertainties, and improve performance over time."]}),"\n"]}),"\n",(0,r.jsx)(o.h2,{id:"code",children:"Code"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-python",children:"# Example: Simple PID Controller for a 1-DOF Joint Position Control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# --- System Parameters ---\n# Robot joint model: simple mass-damper system (approximates a motor-driven joint)\nm_joint = 0.5  # equivalent mass of the joint (kg)\nb_joint = 0.8  # damping coefficient of the joint (Nms/rad)\n\n# --- PID Controller Gains ---\nKp = 20.0 # Proportional gain\nKi = 5.0  # Integral gain\nKd = 3.0  # Derivative gain\n\n# --- Simulation Parameters ---\ndt = 0.01  # time step (s)\nt_final = 10.0 # final simulation time (s)\nt_points = int(t_final / dt)\n\n# --- Initial Conditions ---\nposition = 0.0      # initial joint position (radians)\nvelocity = 0.0      # initial joint velocity (rad/s)\nintegral_error = 0.0 # initial integral error\nprevious_error = 0.0 # initial previous error for derivative term\n\n# --- Desired State (Setpoint) ---\ndesired_position = np.deg2rad(90) # Target joint position: 90 degrees\n\n# --- Data Storage for Plotting ---\ntime_history = np.arange(0, t_final, dt)\nposition_history = []\ndesired_position_history = []\ncontrol_effort_history = []\n\n# --- Simulation Loop ---\nfor t in time_history:\n    position_history.append(position)\n    desired_position_history.append(desired_position)\n\n    # Calculate error\n    error = desired_position - position\n\n    # Update integral error\n    integral_error += error * dt\n\n    # Calculate derivative error\n    derivative_error = (error - previous_error) / dt\n    previous_error = error\n\n    # Calculate PID control output (torque)\n    control_torque = Kp * error + Ki * integral_error + Kd * derivative_error\n    control_effort_history.append(control_torque)\n\n    # Simulate joint dynamics (simple mass-damper)\n    # F = ma + bv => Torque = I*alpha + B*omega (simplified to m*a + b*v for 1-DOF rotation)\n    # Assuming Torque = m_joint * acceleration + b_joint * velocity\n    acceleration = (control_torque - b_joint * velocity) / m_joint\n    velocity += acceleration * dt\n    position += velocity * dt\n\n# --- Plotting Results ---\nplt.figure(figsize=(12, 8))\n\nplt.subplot(2, 1, 1)\nplt.plot(time_history, np.rad2deg(position_history), label='Actual Position')\nplt.plot(time_history, np.rad2deg(desired_position_history), '--', label='Desired Position')\nplt.title('Joint Position Control with PID')\nplt.xlabel('Time (s)')\nplt.ylabel('Position (degrees)')\nplt.grid(True)\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(time_history, control_effort_history, label='Control Torque')\nplt.title('PID Control Effort')\nplt.xlabel('Time (s)')\nplt.ylabel('Torque (Nm)')\nplt.grid(True)\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n"})}),"\n",(0,r.jsx)(o.h2,{id:"gazebo-simulation",children:"Gazebo Simulation"}),"\n",(0,r.jsxs)(o.p,{children:["In Gazebo, control systems are typically implemented using ROS (Robot Operating System) controllers. You can use standard ROS control packages, such as ",(0,r.jsx)(o.code,{children:"ros_control"}),", to define joint-level position, velocity, or effort controllers. These controllers take desired setpoints (e.g., target joint angles) and, using PID or other control laws, generate commands for the simulated robot's joints. Gazebo's physics engine then executes these commands, providing feedback through joint state sensors."]}),"\n",(0,r.jsx)(o.h2,{id:"real-robot-mapping",children:"Real Robot Mapping"}),"\n",(0,r.jsx)(o.p,{children:"On real robots, control systems are often hierarchical. A high-level motion planner might generate a trajectory, which a mid-level controller breaks down into joint-level setpoints. A low-level controller (often running on embedded hardware) then executes the PID or other control loop to drive the motors. Real-world challenges include sensor noise, actuator saturation, friction, and latency. Advanced robot controllers often incorporate feedforward terms, adaptive gains, and robust error handling to compensate for these non-ideal conditions."}),"\n",(0,r.jsx)(o.h3,{id:"hardware-requirements",children:"Hardware Requirements:"}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsx)(o.li,{children:"A robotic platform with controllable joints (e.g., a robotic arm, mobile robot)"}),"\n",(0,r.jsx)(o.li,{children:"Joint position encoders for feedback"}),"\n",(0,r.jsx)(o.li,{children:"Motor drivers or servo controllers that accept torque, velocity, or position commands"}),"\n",(0,r.jsx)(o.li,{children:"A real-time control computer or embedded system"}),"\n"]}),"\n",(0,r.jsx)(o.h2,{id:"lab-exercise",children:"Lab Exercise"}),"\n",(0,r.jsx)(o.h4,{id:"objective",children:"Objective:"}),"\n",(0,r.jsx)(o.p,{children:"Implement and tune a PID controller for a simulated single robot joint."}),"\n",(0,r.jsx)(o.h4,{id:"instructions",children:"Instructions:"}),"\n",(0,r.jsxs)(o.ol,{children:["\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Run the PID Simulation:"})," Execute the provided Python code. Observe how the joint moves to the desired 90-degree position. Note the overshoot and settling time."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Tune Kp:"})," Increase ",(0,r.jsx)(o.code,{children:"Kp"})," significantly (e.g., ",(0,r.jsx)(o.code,{children:"Kp = 50"}),"). What happens to the response? Does it become faster or oscillate more? Reduce ",(0,r.jsx)(o.code,{children:"Kp"})," (e.g., ",(0,r.jsx)(o.code,{children:"Kp = 5"}),"). How does the response change?"]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Tune Kd:"})," Set ",(0,r.jsx)(o.code,{children:"Kp"})," back to ",(0,r.jsx)(o.code,{children:"20"}),". Increase ",(0,r.jsx)(o.code,{children:"Kd"})," (e.g., ",(0,r.jsx)(o.code,{children:"Kd = 10"}),"). How does the derivative term affect overshoot and oscillation? Decrease ",(0,r.jsx)(o.code,{children:"Kd"})," (e.g., ",(0,r.jsx)(o.code,{children:"Kd = 1"}),")."]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Tune Ki:"})," Set ",(0,r.jsx)(o.code,{children:"Kp=20"}),", ",(0,r.jsx)(o.code,{children:"Kd=5"}),". Introduce a small constant external disturbance (e.g., by adding a small value to the ",(0,r.jsx)(o.code,{children:"acceleration"})," calculation in the loop). Observe if there's a steady-state error. Then, increase ",(0,r.jsx)(o.code,{children:"Ki"})," (e.g., ",(0,r.jsx)(o.code,{children:"Ki = 10"}),"). Does the integral term eliminate the steady-state error?"]}),"\n",(0,r.jsxs)(o.li,{children:[(0,r.jsx)(o.strong,{children:"Optimal Tuning:"})," Experiment with different combinations of ",(0,r.jsx)(o.code,{children:"Kp"}),", ",(0,r.jsx)(o.code,{children:"Ki"}),", and ",(0,r.jsx)(o.code,{children:"Kd"})," to achieve a fast response with minimal overshoot and no steady-state error. Document your best set of gains."]}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>s,x:()=>l});var t=n(6540);const r={},i=t.createContext(r);function s(e){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);