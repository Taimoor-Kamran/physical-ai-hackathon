"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[2713],{5732:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"path-planning","title":"Path Planning","description":"Theory","source":"@site/docs/path-planning.mdx","sourceDirName":".","slug":"/path-planning","permalink":"/physical-ai-hackathon/docs/path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Taimoor-Kamran/physical-ai-hackathon/edit/main/frontend/docs/path-planning.mdx","tags":[],"version":"current","frontMatter":{"title":"Path Planning","sidebar_label":"Path Planning"},"sidebar":"docs","previous":{"title":"Localization & Mapping","permalink":"/physical-ai-hackathon/docs/localization-mapping"},"next":{"title":"Manipulation","permalink":"/physical-ai-hackathon/docs/manipulation"}}');var o=i(4848),a=i(8453);const s={title:"Path Planning",sidebar_label:"Path Planning"},r="Path Planning",l={},d=[{value:"Theory",id:"theory",level:2},{value:"Code",id:"code",level:2},{value:"Gazebo Simulation",id:"gazebo-simulation",level:2},{value:"Real Robot Mapping",id:"real-robot-mapping",level:2},{value:"Hardware Requirements:",id:"hardware-requirements",level:3},{value:"Lab Exercise",id:"lab-exercise",level:2},{value:"Objective:",id:"objective",level:4},{value:"Instructions:",id:"instructions",level:4}];function h(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"path-planning",children:"Path Planning"})}),"\n",(0,o.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,o.jsx)(e.p,{children:"Path planning is a critical capability for autonomous robots, enabling them to navigate from a starting point to a target destination while avoiding obstacles and optimizing for various criteria, such as shortest distance, least time, or minimum energy consumption. This field relies heavily on algorithms to search through possible paths and identify the most suitable one."}),"\n",(0,o.jsx)(e.p,{children:"Key components of path planning:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Map Representation:"})," The environment is typically represented as an occupancy grid, a graph, or a continuous space. The choice of representation influences the planning algorithm."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Start and Goal States:"})," The initial and desired final positions (and sometimes orientations) of the robot."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Obstacles:"})," Areas in the environment that the robot cannot traverse."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Constraints:"})," Limitations on the robot's motion (e.g., maximum velocity, turning radius) or environmental rules (e.g., one-way paths)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cost Function:"})," A metric used to evaluate the quality of a path (e.g., path length, time taken, collision risk)."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Common categories of path planning algorithms:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Graph-based Search Algorithms:"})," These algorithms work on discrete representations of the environment (graphs). Nodes represent locations, and edges represent traversable paths between them. Examples include:","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dijkstra's Algorithm:"})," Finds the shortest path from a single source node to all other nodes in a graph with non-negative edge weights."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.em,{children:[(0,o.jsx)(e.em,{children:"A"})," (A-star) Search Algorithm:"]}),"* An extension of Dijkstra's that uses a heuristic function to guide its search, making it more efficient for finding paths to a specific goal."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sampling-based Algorithms:"})," These algorithms explore the configuration space by randomly sampling points and connecting them to build a roadmap or tree. They are effective for high-dimensional spaces and complex environments.","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RRT (Rapidly-exploring Random Tree):"})," Builds a tree by incrementally extending branches towards randomly sampled points until the goal is reached."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"PRM (Probabilistic Roadmap):"})," Constructs a roadmap by connecting randomly sampled valid configurations."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Potential Field Methods:"})," Treat the robot as a particle under the influence of attractive forces from the goal and repulsive forces from obstacles. Simple but can get stuck in local minima."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"code",children:"Code"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Example: A* Pathfinding Algorithm on a 2D Grid\nimport heapq\nimport numpy as np\n\nclass Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.g = 0 # Cost from start to current node\n        self.h = 0 # Heuristic cost from current node to end\n        self.f = 0 # Total cost (g + h)\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\ndef astar_pathfinding(grid, start, end):\n    # Create start and end nodes\n    start_node = Node(start)\n    end_node = Node(end)\n\n    # Initialize open and closed lists\n    open_list = []\n    closed_list = []\n\n    # Add the start node to the open list\n    heapq.heappush(open_list, start_node)\n\n    # Loop until the open list is empty\n    while len(open_list) > 0:\n        # Get the current node (node with the lowest f cost)\n        current_node = heapq.heappop(open_list)\n        closed_list.append(current_node)\n\n        # Check if we have reached the goal\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1] # Return reversed path\n\n        # Generate children (neighbors)\n        children = []\n        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), # 4 directions\n                             (-1, -1), (-1, 1), (1, -1), (1, 1)]: # 8 directions (optional)\n            node_position = (current_node.position[0] + new_position[0],\n                             current_node.position[1] + new_position[1])\n\n            # Make sure within range\n            if node_position[0] > (len(grid) - 1) or node_position[0] < 0 or \\\n               node_position[1] > (len(grid[len(grid)-1]) - 1) or node_position[1] < 0:\n                continue\n\n            # Make sure walkable terrain (0 is walkable)\n            if grid[node_position[0]][node_position[1]] != 0:\n                continue\n\n            # Create new node\n            new_node = Node(node_position, current_node)\n            children.append(new_node)\n\n        # Loop through children\n        for child in children:\n            # Child is already in the closed list\n            if child in closed_list:\n                continue\n\n            # Create the f, g, and h values\n            child.g = current_node.g + 1 # Assuming cost of 1 for each step\n            # Heuristic: Manhattan distance (can use Euclidean for 8 directions)\n            child.h = abs(child.position[0] - end_node.position[0]) + abs(child.position[1] - end_node.position[1])\n            child.f = child.g + child.h\n\n            # Child is already in the open list with a lower f cost\n            if any(open_node.position == child.position and open_node.f < child.f for open_node in open_list):\n                continue\n\n            # Add the child to the open list\n            heapq.heappush(open_list, child)\n\n    return None # No path found\n\n\n# Example Grid (0 = walkable, 1 = obstacle)\ngrid = np.array([\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n])\n\nstart_point = (0, 0)\nend_point = (9, 9)\n\npath = astar_pathfinding(grid, start_point, end_point)\n\nif path:\n    print(\"Path found:\", path)\n    # Visualize the path\n    path_grid = np.copy(grid).astype(float)\n    for r, c in path:\n        path_grid[r, c] = 0.5 # Mark path\n\n    plt.imshow(path_grid, cmap='viridis')\n    plt.colorbar(ticks=[0, 0.5, 1], format=plt.FuncFormatter(lambda val, pos: {0:'Free', 0.5:'Path', 1:'Obstacle'}[val]))\n    plt.title('A* Pathfinding')\n    plt.show()\nelse:\n    print(\"No path found!\")\n"})}),"\n",(0,o.jsx)(e.h2,{id:"gazebo-simulation",children:"Gazebo Simulation"}),"\n",(0,o.jsx)(e.p,{children:"In Gazebo, path planning algorithms can be integrated with ROS navigation stack. The global planner (e.g., A*, Dijkstra, or Navfn) calculates a safe path from the robot's current location to the goal location based on a global costmap (built from sensor data and map information). A local planner (e.g., DWA, TEB) then generates velocity commands to follow this path while performing real-time obstacle avoidance. Gazebo allows for testing these planning algorithms in dynamic environments with various robot models."}),"\n",(0,o.jsx)(e.h2,{id:"real-robot-mapping",children:"Real Robot Mapping"}),"\n",(0,o.jsx)(e.p,{children:"On real robots, path planning faces challenges such as dynamic obstacles, sensor noise, actuator limitations, and imperfect localization. The generated path needs to be dynamically adjusted based on real-time sensor feedback. Real-time re-planning is crucial in unstructured or changing environments. Safety is paramount, requiring robust collision detection and avoidance strategies. Integration with low-level motion control ensures that the planned path is executable by the robot's physical hardware."}),"\n",(0,o.jsx)(e.h3,{id:"hardware-requirements",children:"Hardware Requirements:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mobile Robot Platform:"})," Capable of executing motion commands."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Localization System:"})," Accurate odometry (wheel encoders, IMU) and global localization (e.g., LiDAR-based SLAM, GPS) to know the robot's current pose."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Perception Sensors:"})," (e.g., LiDAR, depth camera) to detect obstacles and build/update maps."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Onboard Computer:"})," Powerful enough to run path planning algorithms and the navigation stack in real-time."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"lab-exercise",children:"Lab Exercise"}),"\n",(0,o.jsx)(e.h4,{id:"objective",children:"Objective:"}),"\n",(0,o.jsx)(e.p,{children:"Implement and visualize the A* pathfinding algorithm on a 2D grid with obstacles."}),"\n",(0,o.jsx)(e.h4,{id:"instructions",children:"Instructions:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Setup:"})," Ensure you have Python and ",(0,o.jsx)(e.code,{children:"numpy"})," installed (",(0,o.jsx)(e.code,{children:"pip install numpy matplotlib"}),")."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsxs)(e.em,{children:[(0,o.jsx)(e.em,{children:"Run A"}),":"]}),"* Execute the provided Python code. Observe the generated grid and the path found by the A* algorithm. The path is marked in a different color."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Modify Grid:"})," Change the ",(0,o.jsx)(e.code,{children:"grid"})," definition to add more obstacles (",(0,o.jsx)(e.code,{children:"1"}),"s) or change their positions. Does the A* algorithm still find a path? What happens if the goal is completely blocked?"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Change Start/End:"})," Experiment with different ",(0,o.jsx)(e.code,{children:"start_point"})," and ",(0,o.jsx)(e.code,{children:"end_point"})," coordinates. Ensure they are valid (i.e., within grid boundaries and not on an obstacle)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Heuristic Function (Challenge):"})," The current heuristic is Manhattan distance. Research and implement Euclidean distance as a heuristic. How does changing the heuristic affect the pathfinding performance (e.g., speed, path quality)? Note: Euclidean distance is often better for 8-directional movement."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Visualize Search (Challenge):"})," Modify the code to visualize the nodes explored by the algorithm (e.g., by marking visited nodes in ",(0,o.jsx)(e.code,{children:"open_list"})," and ",(0,o.jsx)(e.code,{children:"closed_list"})," with different colors on the grid) to better understand how A* works."]}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(h,{...n})}):h(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);